<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JVM：内存结构]]></title>
    <url>%2F2018%2F04%2F09%2FJVM%EF%BC%9A%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[概述Java虚拟机在运行时的区域称为Java运行时数据区，同时会分成不同的区域各司其职，Java虚拟机运行数据区结构如图显示： 作用 方法区所有线程共享，存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。异常：OutOfMemoryError Java栈线程私有，存储Java方法中的局部变量，还包括对象的引用异常：OutOfMemoryError、StackOverFlowError Java堆所有线程共享，存储实例对象。异常：OutOfMemoryError该区域内存最大，是GC主要管理的区域，也称为GC堆 本地方法栈与Java栈类似，但是服务对象是Netive方法。 程序计数器线程私有，用于异常处理，线程恢复等基础功能异常：在JVM中唯一没有OutOfMemoryError的内存区域。 总结]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于1.7和1.8的HashMap分析]]></title>
    <url>%2F2018%2F04%2F04%2F%E5%85%B3%E4%BA%8E1.7%E5%92%8C1.8%E7%9A%84HashMap%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[前言在日常的开发过程中，HashMap是我常用的数据结构体，在分析1.7和1.8的HashMap之间的区别之前，先了解一下HashMap。 简介 HashMap类 12public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable 类介绍定义：基于哈希表的Map接口的实现类，继承了AbstractMap抽象类，同时实现了Map（基于Map），Cloneable（可克隆）,Serializable（序列化）接口。特点：允许空值空键，非安全线程，不保证有序。 HashMap的实现简单来说，HashMap是基于数组+链表的形式来实现的。数组的元素就是键值对（一个链表），数组的下标就是Key的hash值，数组的大小就是HashMap的容量。由于不同的Key计算的hash值可能会相同（hash冲突），链表就是用于解决这种冲突的。即发生冲突时，新元素插入到链表头中，新元素总是添加到数组里，旧元素移到单列表中。假设自己设计一个类似HashMap的类，可以采用数组+Entry的形式实现，Entry对象用来存放Key和Value。其插入和查询的都是O(n)级别的。 示意图 API1234567891011121314V get(Object key); // 获得指定键的值V put(K key, V value); // 添加键值对void putAll(Map&lt;? extends K, ? extends V&gt; m); // 将指定Map中的键值对 复制到 此Map中V remove(Object key); // 删除该键值对boolean containsKey(Object key); // 判断是否存在该键的键值对；是 则返回trueboolean containsValue(Object value); // 判断是否存在该值的键值对；是 则返回trueSet&lt;K&gt; keySet(); // 单独抽取key序列，将所有key生成一个SetCollection&lt;V&gt; values(); // 单独value序列，将所有value生成一个Collectionvoid clear(); // 清除哈希表中的所有键值对int size(); // 返回哈希表中所有 键值对的数量 = 数组中的键值对 + 链表中的键值对boolean isEmpty(); // 判断HashMap是否为空；size == 0时 表示为 空 1.7与1.8HashMap的区别以上的分析主要是针对1.7的分析，其与1.8版本中最大的区别是加入了红黑树。即：数组+链表+红黑树。在实现过程中将原先1.7的Entry换成了Node。当链表长度小于等于8时，两个版本无异，都是链表存放。当链表长度大于8时，就会将链表改成红黑树。由于链表过长的话会导致索引变慢，而红黑树具有快速增删改查的优点，因此长度大于8时采用数组+红黑树的形式实现。有关于红黑树的介绍，可参看《》。 问题探究当 key ==null时，该键值对存放什么位置？当 key ==null时，将该 key-value 的存储位置规定为数组table 中的第1个位置，即table [0]。1234567891011121314151617181920212223242526272829303132 /** * 函数使用原型 */ if (key == null) return putForNullKey(value); /** * 源码分析：putForNullKey(value) */ private V putForNullKey(V value) &#123; // 遍历以table[0]为首的链表，寻找是否存在key==null 对应的键值对 // 1. 若有：则用新value 替换 旧value；同时返回旧的value值 for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123; if (e.key == null) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; // 2 .若无key==null的键，那么调用addEntry（），将空键 &amp; 对应的值封装到Entry中，并放到table[0]中 addEntry(0, null, value, 0); // 注： // a. addEntry（）的第1个参数 = hash值 = 传入0 // b. 即 说明：当key = null时，也有hash值 = 0，所以HashMap的key 可为null // c. 对比HashTable，由于HashTable对key直接hashCode（），若key为null时，会抛出异常，所以HashTable的key不可为null // d. 此处只需知道是将 key-value 添加到HashMap中即可，关于addEntry（）的源码分析将等到下面再详细说明， return null; &#125; equals 和 == 的区别，hashCode 与它们之间的联系？equals是针对于内容，==是针对于地址或者基本数据类型的值。在Object中，equals就是==，即是否指向同一对象。equals于hashCode的联系是：原则 1 ： 如果 x.equals(y) 返回 “true”，那么 x 和 y 的 hashCode() 必须相等 ；原则 2 ： 如果 x.equals(y) 返回 “false”，那么 x 和 y 的 hashCode() 有可能相等，也有可能不等 ；原则 3 ： 如果 x 和 y 的 hashCode() 不相等，那么 x.equals(y) 一定返回 “false” ； HashMap 的长度为什么是 2 的幂次？多线程同时往 HashMap 中 put 数据会发生什么？]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android基础知识点]]></title>
    <url>%2F2016%2F01%2F18%2FAndroid%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[Android基础 四大组件是什么活动（Activity） 服务（Server） 广播（BroadcastReceiver） 内容提供者（ContentProvider） 四大组件的生命周期Activity:onCreate()、onStart()、onPuase()、onResume()、onstop()、onDestoty()、onRestart()Server:onCreate()、onBind()（首次启动会调用前面这两个方法，再次启动就不会调用了）、onUnbind()、onDestoty() Activity之间的通信方式Intent借助类的静态变量借助全局变量/Application借助外部工具 :– 借助SharedPreference– 使用Android数据库SQLite– 赤裸裸的使用File – Android剪切板借助Service Activity各种情况下的生命周期 横竖屏切换的时候，Activity 各种情况下的生命周期5.1 不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次5.2 设置Activity的android:configChanges=”orientation”时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次5.3 设置Activity的android:configChanges=”orientation|keyboardHidden”时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法 Activity与Fragment之间生命周期比较Fragment:onAttach() onCreate() onCreateView() onActivityCreate() onstart() onResume() onPause() onStop() onDestoryView() onDestory() onDetach() Activity上有Dialog的时候按Home键时的生命周期onSaveInstanceState –&gt; onPause –&gt; onStop onRestart –&gt;onStart—&gt;onResume 两个Activity 之间跳转时必然会执行的是哪几个方法？一般情况下比如说有两个activity,分别叫A,B。当在A 里面激活B 组件的时候, A会调用onPause()方法,然后B调用onCreate() ,onStart(), onResume()。这个时候B覆盖了A的窗体, A会调用onStop()方法。如果B是个透明的窗口,或者是对话框的样式, 就不会调用A的onStop()方法。如果B已经存在于Activity栈中，B就不会调用onCreate()方法。 Activity的四种启动模式对比standard:每次启动一个Activity都会重写创建一个新的实例，不管这个实例存不存在singleTop:判断新的activity已经位于栈顶，那么这个Activity不会被重写创建，同时它的onNewIntent方法会被调用，通过此方法的参数我们可以去除当前请求的信息。如果栈顶不存在该Activity的实例，则情况与standard模式相同singleTask：如果栈中存在这个Activity的实例就会复用这个Activity，不管它是否位于栈顶，复用时，会将它上面的Activity全部出栈，并且会回调该实例的onNewIntent方法singleInstance :该模式具备singleTask模式的所有特性外，与它的区别就是，这种模式下的Activity会单独占用一个Task栈，具有全局唯一性，即整个系统中就这么一个实例，由于栈内复用的特性，后续的请求均不会创建新的Activity实例，除非这个特殊的任务栈被销毁了。以singleInstance模式启动的Activity在整个系统中是单例的，如果在启动这样的Activiyt时，已经存在了一个实例，那么会把它所在的任务调度到前台，重用这个实例。 Activity状态保存如何恢复 service和activity怎么进行数据交互？Activity与Service之间的交互 谈谈你对ContentProvider的理解 说说ContentProvider、ContentResolver、ContentObserver 之间的关系 请描述一下广播BroadcastReceiver的理解 在manifest 和代码中如何注册和使用BroadcastReceiver?代码中使用广播（动态注册）：15.1 实现一个广播接收器，继承BroadcastReceiver,实现onReceive方法，在其中实现主要的逻辑。15.2 使用IntentFilter()添加Action，注册广播。让广播接收器和IntentFilter绑定。registerReceiver15.3 通过Intent发送一个广播消息 本地广播和全局广播有什么差别？BroadcastReceiver是针对应用间、应用与系统间、应用内部进行通信的一种方式LocalBroadcastReceiver仅在自己的应用内发送接收广播，也就是只有自己的应用能收到，数据更加安全广播只在这个程序里，而且效率更高。LocalBroadcastReceiver不能静态注册，只能采用动态注册的方式。 AlertDialog,popupWindow,Activity区别 Application 和 Activity 的 Context 对象的区别 Android属性动画特性 写一个回调demo 123456789101112131415161718192021222324252627/** * 回调接口 * */ public interface Callback &#123; public void execute(String s); &#125;public class B &#123; public void Test(int n ,Callback callback) &#123; callback.execute("int转成String"+n);//进行回调 &#125; &#125;protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); B b=new B(); b.Test(100 ,new Callback()&#123; @Override public void execute(String s) &#123; // TODO Auto-generated method stub System.out.println("实现回调"); System.out.println(s); &#125;&#125;); &#125; RecycleView的使用RecyclerView 是一个增强版的ListView，不仅可以实现和ListView同样的效果，还优化了ListView中存在的各种不足之处copy:① RecyclerView封装了viewholder的回收复用，也就是说RecyclerView标准化了ViewHolder，编写Adapter面向的是ViewHolder而不再是View了，复用的逻辑被封装了，写起来更加简单。② 提供了一种插拔式的体验，高度的解耦，异常的灵活，针对一个Item的显示RecyclerView专门抽取出了相应的类，来控制Item的显示，使其的扩展性非常强。例如：你想控制横向或者纵向滑动列表效果可以通过LinearLayoutManager这个类来进行控制(与GridView效果对应的是GridLayoutManager,与瀑布流对应的还StaggeredGridLayoutManager等)，也就是说RecyclerView不再拘泥于ListView的线性展示方式，它也可以实现GridView的效果等多种效果。你想控制Item的分隔线，可以通过继承RecyclerView的ItemDecoration这个类，然后针对自己的业务需求去抒写代码。③ 可以控制Item增删的动画，可以通过ItemAnimator这个类进行控制，当然针对增删的动画，RecyclerView有其自己默认的实现。 序列化的作用，以及Android两种序列化的区别Serializable接口：Parcelable接口：相比于Seriablizable具有更好的性能。实现Parcelable接口的对象就可以实现序列化并可以通过Intent和Binder传递。 属性动画差值器和估值器]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
</search>
